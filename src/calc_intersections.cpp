// Partial version of main.cpp which only goes to the point of outputting the list of edges intersecting each hex.
// This may be useful when mapping multiple sets of data using the same nodes, same hex size and same eccentricity.
// It is to be used in conjunction with [TBA].cpp, which accepts as input the data generated by this file along with the pairwise data

#include "main.h"
#include "probability.h"
#include "sim.Parameters.h"
#include "sim.Dispatcher.h"

#include <chrono>
#include <vector>

using namespace std;

//------------------------------------------------
// compute map and run permutation test
// [[Rcpp::export]]
Rcpp::List calc_intersections_cpp(Rcpp::List args)
{
        int hex, node1, node2, ell;
        double dist, linear_eccentricity, semi_minor;
        
        // start timer
        //chrono::high_resolution_clock::time_point t0 = chrono::high_resolution_clock::now();
  
        //Convert Rcpp arguments to native c++ arguments ------------------------------------------------------------------------------------------------
  
        // load data and parameters
        print("Loading data and parameters");
        vector<double> node_long = rcpp_to_vector_double(args["node_long"]);                  //Longitude of data nodes
        vector<double> node_lat = rcpp_to_vector_double(args["node_lat"]);                    //Latitude of data nodes
        vector<double> hex_long = rcpp_to_vector_double(args["hex_long"]);                    //Longitude of hex cells
        vector<double> hex_lat = rcpp_to_vector_double(args["hex_lat"]);                      //Latitude of hex cells
        int min_intersections = rcpp_to_int(args["min_intersections"]);                       //Minimum number of ellipses required to intersect a hex
        double eccentricity = rcpp_to_double(args["eccentricity"]);                           //Eccentricity of ellipses (see help for details)
        double inv_eccentricity = 1.0 / eccentricity;
  
  
        //Derived values/fixed constants ------------------------------------------------------------------------------------------------
  
        int Nnodes = node_long.size();                  //Number of nodes
        int Nells = (Nnodes*(Nnodes-1))/2;               //Number of ellipses
        int Nhex = hex_long.size();                     //Number of hex cells
  
        //Create ellipses ------------------------------------------------------------------------------------------------
  
        print("Setting up ellipses");
        
        // ellipse properties
        vector<double> semi_major(Nells, 0.0);            //Semi-major axis of ellipse
        vector<double> xfocus1(Nells, 0.0);               //x-coordinate of focus 1 of each ellipse
        vector<double> yfocus1(Nells, 0.0);               //y-coordinate of focus 1 of each ellipse
        vector<double> xfocus2(Nells, 0.0);               //x-coordinate of focus 2 of each ellipse
        vector<double> yfocus2(Nells, 0.0);               //y-coordinate of focus 2 of each ellipse
        vector<double> area_inv(Nells, 0.0);              //Inverse of area of each ellipse
  
    // loop through ellipses
        ell = 0;
        for (node1 = 0; node1 < Nnodes; node1++)
        {
                for (node2 = node1 + 1; node2 < Nnodes; node2++)
                {
                        // store foci and centre of ellipse
                        xfocus1[ell] = node_long[node1];
                        yfocus1[ell] = node_lat[node1];
                        xfocus2[ell] = node_long[node2];
                        yfocus2[ell] = node_lat[node2];
      
                        // store long radius and inverse area of ellipse
                        dist = dist_euclid_2d(node_long[node1], node_lat[node1], node_long[node2], node_lat[node2]);
                        linear_eccentricity = 0.5 * dist;
                        semi_major[ell] = linear_eccentricity*inv_eccentricity;
                        semi_minor = sqrt(sq(semi_major[ell]) - sq(linear_eccentricity));
                        area_inv[ell] = 1.0 / (M_PI * semi_major[ell] * semi_minor);
                        
                        ell++;
                }
        }
  
        //chrono_timer(t0);
  
        //Create list of ellipses intersecting each hex ------------------------------------------------------------------------------------------------

        print("Computing intersection data");
  
    // hex properties
        vector<double> hex_weights(Nhex, 0.0);          //Sum of weights of hex
        vector<double> inv_hex_weights(Nhex, 0.0);      //Inverse sum of weights of hex
        vector<int> Nintersections(Nhex, 0);            //Number of ellipses intersecting hex
        vector<vector<int>> intersections(Nhex);        //List of ellipses intersecting each hex
        
        // loop through hexes
        for (hex = 0; hex < Nhex; hex++)
        {
                // test every ellipse for intersection with this hex
                for (ell = 0; ell < Nells; ell++)
                {
                        if (ellipse_check(hex_long[hex], hex_lat[hex], xfocus1[ell], yfocus1[ell], xfocus2[ell], yfocus2[ell], semi_major[ell]))
                        {                                
                                // add to hex weights
                                hex_weights[hex] += area_inv[ell];
                                
                                // store this intersection
                                intersections[hex].push_back(ell);
                                Nintersections[hex]++;
                        }
                }
                // divide hex value by weight
                if (Nintersections[hex] >= min_intersections) 
                {
                        inv_hex_weights[hex] = 1.0 / hex_weights[hex];
                }
                else
                {
                        inv_hex_weights[hex] = 1.0;
                }
        }
  
        //chrono_timer(t0);
        
        // return list
        return Rcpp::List::create(Rcpp::Named("inv_hex_weights") = inv_hex_weights,
                           Rcpp::Named("Nintersections") = Nintersections,
                           Rcpp::Named("intersections") = intersections);
}
