---
title: "Basic tutorial"
author: "Keith Fraser and Bob Verity"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{"Basic tutorial"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE}
set.seed(1)
library(RMAPI)
```

This vignette goes through a basic RMAPI analysis, using simulated data to test different methods. It covers:

1. Simulating/loading data into R
2. Creating a project and binding data to the project
3. Creating a hex-map and checking coverage
4. Running simulations
5. Plotting results
6. Repeat analysis using an explicit fitted model


## Simulating/loading data

RMAPI uses pairwise information (i.e. statistics) between a series of spatial nodes (i.e. observations) to test for areas of significant spatial discontinuity, therefore, the basic inputs to RMAPI are: 1) coordinates of nodes, 2) values of pairwise statistics. Node coordinates need to be in dataframe format, with two columns: `long` and `lat`, and pairwise statistics need to be formatted as a square matrix.

For the sake of this vignette we will use built-in functions to simulate data in the correct format, and with known spatial barriers. First, we will generate node coordinates uniformly at random over the sampling region. This is intended to represent a situation where we do not have control over sampling locations and therefore cannot create a perfect sampling grid - for example when sampling from major cities:

```{r}
# define coordinates of nodes
node_df <- data.frame(long = runif(100, -1.548, -1.478), lat = runif(100, 53.347, 53.379))
```

Next we create a list of polygons that represent barriers to gene flow. Each element of this list should be a dataframe specifying the coordinates of a polygon, which must make a complete ring (i.e. the final row must be identical to the first). We also need to define the penalty associated with each barrier:

```{r}
# define barriers
barrier_list <- list()
barrier_list[[1]] <- data.frame(long = c(-1.54, -1.51, -1.49, -1.5, -1.535, -1.54),
                                lat = c(53.365, 53.37, 53.365, 53.36, 53.36, 53.365))
barrier_penalty <- 5
```

We can now simulate statistical values between nodes. The `barrier_method = 2` method used here draws a straight line between nodes and calculates the intersection with barrier polygons before applying the barrier penalty per unit intersection, meaning lines that go long-ways through a barrier experience a greater penalty. We also use `dist_transform = 2` here, which assumes that values fall off exponentially with distance with rate `lambda`. Finally, random error is applied to all pairwise statistics in the form of Gaussian noise with standard deviation `eps`. Further details of barrier penalty methods and transformations can be found in the help for the `sim_simple()` function.

```{r}
# simulate pairwise statistics
sim_stat <- sim_simple(node_long = node_df$long,
                       node_lat = node_df$lat,
                       barrier_list = barrier_list,
                       barrier_penalty = barrier_penalty,
                       barrier_method = 2,
                       dist_transform = 2,
                       lambda = 50,
                       eps = 0.2)
```

If loading data from file then ensure it is in the same format as this simulated data.


## Creating a project and binding data

RMAPI works using projects, which are essentially just lists containing all data, input and outputs in one place. We can create a new project, and then bind our data to the project:

```{r, fig.width=7, fig.height=5}
# create new RMAPI project
p <- rmapi_project()

# bind data
p <- bind_data(p, node_df$long, node_df$lat, sim_stat)
```

Once we have data bound to a project we can use the `plot_dist()` function to explore the basic relationship between distance and pairwise statistical values:

```{r, fig.width=7, fig.height=5}
# plot basic relationship between spatial distance and statistic
plot_dist(p)
```

We can see the general shape of exponential fall-off, which we should expect from our simulation parameters, but the noise makes it very difficult to see if there are any more subtle patterns, e.g. spatial barriers.


## Creating a hex map and testing coverage

Next, we need to create a hex-map:

```{r}
# set up map
p <- create_map(p, hex_size = 0.002)
```

Once we have a hex-map we can use it to explore different values of the ellipse eccentricity used in the RMAPI method. An eccentricity of 1 defines a straight line between points, and an eccentricity of 0 represents a perfect circle. Whatever our chosen value, we should ensure that the number of ellipses intersecting each hex (the "coverage") is sufficient to reduce noise, and increase reliability of the permutation testing procedure. We suggest that a minimum coverage of 100 is a good rule of thumb:

```{r, fig.width=10, fig.height=4}
# check that sufficient coverage
plot_coverage(p, eccentricity = 0.9)
```

Here we can see that an eccentricity of 0.9 provides good coverage over most of the map, although we should be wary of values on the far East-West edges.


## Running simulations

Now we are ready to run permutation-testing simulations. The 

```{r, fig.width=10, fig.height=4}
# run simulations
p <- run_sims(p, n_perms = 1e3, eccentricity = 0.9, n_breaks = 1, report_progress = FALSE)

# plot hex values
plot1 <- plot_map(p, barrier_list = barrier_list)

# plot hex ranks
plot2 <- plot_map(p, variable = "hex_ranks", barrier_list = barrier_list)

# use gridExtra package to arrange ggplot objects
library(gridExtra)
grid.arrange(plot1, plot2, ncol = 2)
```

```{r, fig.width=10, fig.height=4}
# run simulations
p <- run_sims(p, n_perms = 1e3, eccentricity = 0.9, n_breaks = 20, report_progress = FALSE)

# plot hex values
plot1 <- plot_map(p, barrier_list = barrier_list)

# plot hex ranks
plot2 <- plot_map(p, variable = "hex_ranks", barrier_list = barrier_list)

# use gridExtra package to arrange ggplot objects
grid.arrange(plot1, plot2, ncol = 2)
```

We can also produce an interactive map:

```{r, fig.width=7, fig.height=5}
# produce interactive map
plot3 <- plot_leaflet(p, variable = "hex_ranks")
overlay_points(plot3, node_df$long, node_df$lat)
```


## Fitting a model

```{r, fig.width=7, fig.height=5}
# fit model to data
p <- fit_model(p, type = 2)

# plot model fit over data
plot_dist(p)
```

```{r, fig.width=10, fig.height=4}
# run simulations
p <- run_sims(p, null_method = 2, n_perms = 1e3, eccentricity = 0.9, n_breaks = 1, report_progress = FALSE)

# plot hex values
plot1 <- plot_map(p, barrier_list = barrier_list)

# plot hex ranks
plot2 <- plot_map(p, variable = "hex_ranks", barrier_list = barrier_list)

# use gridExtra package to arrange ggplot objects
grid.arrange(plot1, plot2, ncol = 2)
```

